     1                                  ; How it works:
     2                                  ; - Iterates trough all numbers from 0 to 1000
     3                                  ; - Checks if the current number is a multiple of 3 or 5
     4                                  ; - If true, add number to eax
     5                                  ; - Print the sum
     6                                  ; - Exit Program returning 0
     7                                  
     8                                  ; Registers
     9                                  ; r10 is used for the sum
    10                                  ; r8 is used to do the loop
    11                                  
    12                                  SECTION .data
    13                                  SECTION .bss
    14                                      OutStrLeng:  EQU 8 
    15 00000000 <res 00000008>              OutStr:      resb OutStrLeng
    16                                  SECTION .text
    17                                  
    18                                  global _start
    19                                  
    20                                  _start:
    21                                      ;setup data
    22 00000000 41B800000000                mov r8, 0           ; will be used for the loop
    23 00000006 41BA00000000                mov r10, 0          ; contains the sum
    24                                  
    25                                      ;performing loop
    26                                  loop:
    27 0000000C E837000000                  call check_number   ; calls check_number to check the current number in loop
    28 00000011 49FFC0                      inc r8              ; increment current number by 1
    29 00000014 4981F8E8030000              cmp r8, 1000        ; Pr√ºft, ob r8 bereits bei 1000 ist
    30 0000001B 75EF                        jne loop            ; Jumps to loop-section if max iterations are not reached
    31                                  
    32 0000001D 4152                        push r10
    33                                      ;mov r10, ecx
    34                                  
    35 0000001F 4C891425[00000000]          mov qword [OutStr], r10
    36                                      ;sys_write sum
    37 00000027 B801000000                  mov rax, 1          ; code for sys_write
    38 0000002C BF01000000                  mov rdi, 1          ; stdout
    39 00000031 488B3424                    mov rsi, [rsp]     ; buffer
    40 00000035 BA08000000                  mov rdx, 8 ; buffer length                
    41 0000003A 0F05                        syscall
    42                                  
    43                                      ;sys_exit
    44 0000003C B83C000000                  mov rax, 60         ; code for sys_exit
    45 00000041 BF00000000                  mov rdi, 0          ; returning 0 in sys_exit
    46 00000046 0F05                        syscall             
    47                                  
    48                                  check_number:
    49                                      ;set up division
    50 00000048 4C89C0                      mov rax, r8         ; number to be divided
    51 0000004B BA00000000                  mov rdx, 0          ; i don't know what this does
    52                                  
    53                                      ;check if current number (r8) is a multiple of 3
    54 00000050 BB03000000                  mov rbx, 3          ; number to divide number in eax
    55 00000055 48F7F3                      div rbx             ; divide. rdx contains remainder, rax contains quotient
    56 00000058 4883FA00                    cmp rdx, 0          ; compare remainder with 0. if true, number is multiple of 3
    57 0000005C 740F                        je add_number
    58                                  
    59                                      ;check if current number (r8) is a multiple of 5
    60 0000005E BB05000000                  mov rbx, 5          ; number to divide number in eax
    61 00000063 48F7F3                      div rbx             ; divide. edx contains remainder, eax contains quotient
    62 00000066 4883FA00                    cmp rdx, 0          ; compare remainder with 0. if true, number is multiple of 5
    63 0000006A 7401                        je add_number
    64 0000006C C3                          ret
    65                                      
    66                                  add_number:
    67 0000006D 4D01C2                      add r10, r8         ; adds the current number to existing sum
    68 00000070 C3                          ret
